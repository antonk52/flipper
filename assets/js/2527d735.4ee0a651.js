"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[8462],{3905:(e,t,n)=>{n.r(t),n.d(t,{MDXContext:()=>d,MDXProvider:()=>u,mdx:()=>g,useMDXComponents:()=>c,withMDXComponents:()=>p});var o=n(67294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(){return r=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var o in n)Object.prototype.hasOwnProperty.call(n,o)&&(e[o]=n[o])}return e},r.apply(this,arguments)}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,o,a=function(e,t){if(null==e)return{};var n,o,a={},r=Object.keys(e);for(o=0;o<r.length;o++)n=r[o],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(o=0;o<r.length;o++)n=r[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var d=o.createContext({}),p=function(e){return function(t){var n=c(t.components);return o.createElement(e,r({},t,{components:n}))}},c=function(e){var t=o.useContext(d),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},u=function(e){var t=c(e.components);return o.createElement(d.Provider,{value:t},e.children)},h={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},m=o.forwardRef((function(e,t){var n=e.components,a=e.mdxType,r=e.originalType,i=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),p=c(n),u=a,m=p["".concat(i,".").concat(u)]||p[u]||h[u]||r;return n?o.createElement(m,l(l({ref:t},d),{},{components:n})):o.createElement(m,l({ref:t},d))}));function g(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var r=n.length,i=new Array(r);i[0]=m;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:a,i[1]=l;for(var d=2;d<r;d++)i[d]=n[d];return o.createElement.apply(null,i)}return o.createElement.apply(null,n)}m.displayName="MDXCreateElement"},3850:(e,t,n)=>{n.r(t),n.d(t,{frontMatter:()=>l,contentTitle:()=>s,metadata:()=>d,toc:()=>p,default:()=>u});var o=n(83117),a=n(80102),r=(n(67294),n(3905)),i=["components"],l={id:"supporting-layout",title:"Implementing Layout Inspection"},s=void 0,d={unversionedId:"extending/supporting-layout",id:"extending/supporting-layout",isDocsHomePage:!1,title:"Implementing Layout Inspection",description:"To enable the Flipper layout inspector on a new platform, just implement a client plugin with id Inspector which implements the following interface:",source:"@site/../docs/extending/supporting-layout.mdx",sourceDirName:"extending",slug:"/extending/supporting-layout",permalink:"/flipper/docs/extending/supporting-layout",editUrl:"https://github.com/facebook/flipper/blob/main/website/../docs/extending/supporting-layout.mdx",tags:[],version:"current",frontMatter:{id:"supporting-layout",title:"Implementing Layout Inspection"},sidebar:"setup",previous:{title:"Secure Communication",permalink:"/flipper/docs/extending/establishing-a-connection"},next:{title:"Crash Reporter",permalink:"/flipper/docs/setup/plugins/crash-reporter"}},p=[{value:"Node",id:"node",children:[],level:3},{value:"Plugin Interface",id:"plugin-interface",children:[],level:3}],c={toc:p};function u(e){var t=e.components,n=(0,a.Z)(e,i);return(0,r.mdx)("wrapper",(0,o.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,r.mdx)("p",null,"To enable the Flipper layout inspector on a new platform, just implement a client plugin with id ",(0,r.mdx)("inlineCode",{parentName:"p"},"Inspector")," which implements the following interface:"),(0,r.mdx)("p",null,"Note that we're using ",(0,r.mdx)("a",{parentName:"p",href:"https://flow.org/en/docs/types/objects/"},"Flow")," syntax to specify this JSON API."),(0,r.mdx)("h3",{id:"node"},"Node"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-ts"},"type NodeId = string;\n\ntype InspectorValue = {\n  __type__: 'auto' | 'text' | 'number' | 'boolean' | 'enum' | 'color',\n  __mutable__: boolean,\n  value: number | string | boolean,\n};\n\ntype Node = {\n  id: NodeId,\n  name: string,\n  data: ?{string: Object},\n  children: Array<NodeId>,\n  attributes: ?Array<{name: string, value: string}>,\n  decoration: ?string,\n};\n")),(0,r.mdx)("p",null,"Node is the core data type of the layout inspector. The Flipper desktop plugin visualizes a tree of nodes with associated data and attributes. Any UI or data model which can be modeled as a tree of nodes can be inspected using the layout inspector. Data associated with the nodes can also be edited."),(0,r.mdx)("p",null,(0,r.mdx)("inlineCode",{parentName:"p"},"id")," is a stable globally unique node identifier."),(0,r.mdx)("p",null,(0,r.mdx)("inlineCode",{parentName:"p"},"name")," is the user facing identifier for this node. It does not need to be unique. Typically the class name of the node is used as the node's name."),(0,r.mdx)("p",null,(0,r.mdx)("inlineCode",{parentName:"p"},"data")," is a set of named JSON objects representing data associated with the node. This data will be rendered as immutable by default, to the user of the plugin but can be made mutable by wrapping any value in a InspectorValue with the ",(0,r.mdx)("inlineCode",{parentName:"p"},"__mutable__")," attribute set to true."),(0,r.mdx)("p",null,"InspectorValue can also be used to change the parsed type of the value, such as parsing a number as a color to show the value in a color picker."),(0,r.mdx)("p",null,(0,r.mdx)("inlineCode",{parentName:"p"},"children")," is a list of identifiers pointing to children of this node. This is a list of identifiers instead of a list of nodes to allow nodes to be lazily fetched and instantiated."),(0,r.mdx)("p",null,(0,r.mdx)("inlineCode",{parentName:"p"},"attributes")," is a list of key:value pairs which are displayed alongside the name in the layout inspector."),(0,r.mdx)("p",null,(0,r.mdx)("inlineCode",{parentName:"p"},"decoration")," is a string identifying the optional icon used to decorate a node in the layout inspector. Adding new decoration options requires adding an icon file to the Sonar desktop app. Currently componentkit and litho decorations are supported."),(0,r.mdx)("h3",{id:"plugin-interface"},"Plugin Interface"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-ts"},"interface ClientLayoutPlugin {\n  Node getRoot();\n  GetNodesResponse getNodes({ids: Array<NodeId>});\n  GetAllNodesResponse getAllNodes();\n  void setData({id: NodeId, path: Array<string>, value: any});\n  void setHighlighted({id: ?NodeId});\n  void setSearchActive({active: boolean});\n  GetSearchResultsResponse getSearchResults({query: string});\n};\n\ninterface DesktopLayoutPlugin {\n  void invalidate({id: NodeId});\n  void select({path: Array<NodeId>});\n};\n\ntype GetNodesResponse = {\n  elements: Array<Node>\n};\ntype GetAllNodesResponse = {\n  elements: Array<Node>,\n  rootElement: NodeId\n};\ntype GetSearchResultsResponse = {\n  results: ?SearchResultNode,\n  query: string\n};\n\ntype SearchResultNode = {\n  id: NodeId,\n  isMatch: boolean,\n  element: Node,\n  children: ?Array<SearchResultNode>\n}\ntype NodeId = string;\n")),(0,r.mdx)("p",null,(0,r.mdx)("strong",{parentName:"p"},"getRoot"),": Return the root node of your hierarchy. This is the entry point of Flipper's traversal of your layout."),(0,r.mdx)("p",null,(0,r.mdx)("strong",{parentName:"p"},"getNodes"),": Map a set of NodeIds to their corresponding nodes. This call is used to among other things query the children of a node."),(0,r.mdx)("p",null,(0,r.mdx)("strong",{parentName:"p"},"getAllNodes"),": Similar to getNodes, this should return all nodes in the current layout tree. Ordinarily, nodes are requested lazily, however this exists for taking snapshots of the current state."),(0,r.mdx)("p",null,(0,r.mdx)("strong",{parentName:"p"},"setData"),": Set the data of an mutable data object returned as part of the data field of a node. The id parameter identifies the node, the path parameter is a index path into an object, e.g. ",(0,r.mdx)("inlineCode",{parentName:"p"},"['bounds', 'left']")," and the value parameter is a value of appropriate type to be used as an override."),(0,r.mdx)("p",null,(0,r.mdx)("strong",{parentName:"p"},"setHighlighted"),": Mark a node as highlighted. It is expected that implementations adds a colored overlay to the node identified by id on screen, so that as the user browses the layout tree in flipper, they can easily see on the the client display the nodes they are interacting with. Passing a null id parameter removes the current highlight without highlighting a new node."),(0,r.mdx)("p",null,(0,r.mdx)("strong",{parentName:"p"},"setSearchActive"),": The user has clicked on the crosshair button in Sonar. This feature allows the user to click on an element in the client UI to cause flipper to highlight the corresponding node in the layout tree. A colored overlay should be shown over the whole screen until ",(0,r.mdx)("inlineCode",{parentName:"p"},"setSearchActive")," is called with ",(0,r.mdx)("inlineCode",{parentName:"p"},"active: false"),". While ",(0,r.mdx)("inlineCode",{parentName:"p"},"setSearchActive")," is true, clicking an element in the client UI should trigger a ",(0,r.mdx)("inlineCode",{parentName:"p"},"select")," call to the flipper desktop, with the path of ids from root to selected node e.g ",(0,r.mdx)("inlineCode",{parentName:"p"},"select(['node1', 'node6', 'node65'])")," to select a grandchild of ",(0,r.mdx)("inlineCode",{parentName:"p"},"node1"),"."),(0,r.mdx)("p",null,(0,r.mdx)("strong",{parentName:"p"},"getSearchResults"),": Execute a query on all nodes in the tree, and return a subtree of the layout tree that contains all matching nodes and those on the path to the from the root. A parent that does not itself match the query but exists on the path to a node that does, should have attribute ",(0,r.mdx)("inlineCode",{parentName:"p"},"isMatch: false")," and only the matching nodes should have ",(0,r.mdx)("inlineCode",{parentName:"p"},"isMatch: true"),". Nodes not on the path from root to a match need not be included in the returned tree. Be careful not to confuse this method with the unrelated ",(0,r.mdx)("inlineCode",{parentName:"p"},"setSearchActive"),", which unfortunately shares a similar name."),(0,r.mdx)("p",null,"Whenever a node or subtree changes it is expected that the client sends a ",(0,r.mdx)("inlineCode",{parentName:"p"},"invalidate")," command to the desktop app over the active connection. This will invalidate the cache of the subtree anchored by the node with the given id."))}u.isMDXComponent=!0}}]);